<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The CSI 106 Maze Project &mdash; Runestone Interactive Overview</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.0.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="_static/activecode.css" type="text/css" />
    <link rel="stylesheet" href="_static/fitb.css" type="text/css" />
    <link rel="stylesheet" href="_static/clickable.css" type="text/css" />
    <link rel="stylesheet" href="_static/pytutor.css" type="text/css" />
    <link rel="stylesheet" href="_static/modal-basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/datafile.css" type="text/css" />
    <link rel="stylesheet" href="_static/dragndrop.css" type="text/css" />
    <link rel="stylesheet" href="_static/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="_static/livecode.css" type="text/css" />
    <link rel="stylesheet" href="_static/parsons.css" type="text/css" />
    <link rel="stylesheet" href="_static/lib/prettify.css" type="text/css" />
    <link rel="stylesheet" href="_static/poll.css" type="text/css" />
    <link rel="stylesheet" href="_static/tabbedstuff.css" type="text/css" />
    <link rel="stylesheet" href="_static/video.css" type="text/css" />
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/2.3.1/""/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/jquery-ui-1.10.3.custom.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="_static/runestone-custom-sphinx-bootstrap.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/runestonebase.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/jquery.highlight.js"></script>
    <script type="text/javascript" src="_static/bookfuncs.js"></script>
    <script type="text/javascript" src="_static/codemirror.js"></script>
    <script type="text/javascript" src="_static/xml.js"></script>
    <script type="text/javascript" src="_static/css.js"></script>
    <script type="text/javascript" src="_static/htmlmixed.js"></script>
    <script type="text/javascript" src="_static/python.js"></script>
    <script type="text/javascript" src="_static/javascript.js"></script>
    <script type="text/javascript" src="_static/activecode.js"></script>
    <script type="text/javascript" src="_static/skulpt.min.js"></script>
    <script type="text/javascript" src="_static/skulpt-stdlib.js"></script>
    <script type="text/javascript" src="_static/clike.js"></script>
    <script type="text/javascript" src="_static/animationbase.js"></script>
    <script type="text/javascript" src="_static/mchoice.js"></script>
    <script type="text/javascript" src="_static/timedmc.js"></script>
    <script type="text/javascript" src="_static/fitb.js"></script>
    <script type="text/javascript" src="_static/timedfitb.js"></script>
    <script type="text/javascript" src="_static/timed.js"></script>
    <script type="text/javascript" src="_static/clickable.js"></script>
    <script type="text/javascript" src="_static/timedclickable.js"></script>
    <script type="text/javascript" src="_static/d3.v2.min.js"></script>
    <script type="text/javascript" src="_static/jquery.ba-bbq.min.js"></script>
    <script type="text/javascript" src="_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script type="text/javascript" src="_static/pytutor.js"></script>
    <script type="text/javascript" src="_static/codelens.js"></script>
    <script type="text/javascript" src="_static/skulpt.min.js"></script>
    <script type="text/javascript" src="_static/skulpt-stdlib.js"></script>
    <script type="text/javascript" src="_static/datafile.js"></script>
    <script type="text/javascript" src="_static/dragndrop.js"></script>
    <script type="text/javascript" src="_static/timeddnd.js"></script>
    <script type="text/javascript" src="_static/livecode.js"></script>
    <script type="text/javascript" src="_static/clike.js"></script>
    <script type="text/javascript" src="_static/lib/jquery.min.js"></script>
    <script type="text/javascript" src="_static/lib/jquery-ui.min.js"></script>
    <script type="text/javascript" src="_static/lib/jquery.ui.touch-punch.min.js"></script>
    <script type="text/javascript" src="_static/lib/prettify.js"></script>
    <script type="text/javascript" src="_static/lib/underscore-min.js"></script>
    <script type="text/javascript" src="_static/lib/lis.js"></script>
    <script type="text/javascript" src="_static/parsons_setup.js"></script>
    <script type="text/javascript" src="_static/parsons.js"></script>
    <script type="text/javascript" src="_static/parsons-noconflict.js"></script>
    <script type="text/javascript" src="_static/poll.js"></script>
    <script type="text/javascript" src="_static/reveal.js"></script>
    <script type="text/javascript" src="_static/shortanswer.js"></script>
    <script type="text/javascript" src="_static/tabbedstuff.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script type="text/javascript" src="_static/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.0.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <script type="text/javascript" src="_static/waypoints.min.js"></script>
    <script type="text/javascript" src="_static/rangy-core.js"></script>
    <script type="text/javascript" src="_static/rangy-textrange.js"></script>
    <script type="text/javascript" src="_static/rangy-cssclassapplier.js"></script>
    <script type="text/javascript" src="_static/user-highlights.js"></script>
    <script type="text/javascript" src="_static/jquery.idle-timer.js"></script>
    <script type="text/javascript" src="_static/processing-1.4.1.min.js"></script>
    <script type="text/javascript" src="_static/jquery.hotkey.js"></script>
    <script type="text/javascript" src="_static/jquery-migrate-1.2.1.min.js"></script>
    <link rel="top" title="Runestone Interactive Overview" href="#" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<script type="text/javascript">
  eBookConfig = {};
  eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
  eBookConfig.app = eBookConfig.host+'/runestone';
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.course = 'maze';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.isLoggedIn = false;
  eBookConfig.useRunestoneServices = false;
  eBookConfig.python3 = false;
</script>

<div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&status=0";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>



  </head>
  <body role="document">


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        <a class="brand-logo" style='background: transparent url("_static/img/logo_small.png") no-repeat 0px 0px;' href="/runestone/default/user/login">&nbsp; </a>
        <a class="navbar-brand" href="#">Maze</a>
      </div>
    </div>

    <div class="navbar-collapse collapse navbar-ex1-collapse">

      <ul class="nav navbar-nav navbar-right">

        <li class="divider-vertical"></li>

        <!-- social media dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-share-alt" style="opacity: 0.9"></i>
          </a>
          <ul class="dropdown-menu social-menu">
              <li>
                <div>
                  <b>Runestone in social media:</b>
                </div>
                <a href="https://twitter.com/iRunestone" class="twitter-follow-button" data-show-count="true">Follow @iRunestone</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                <div class="fb-like" data-href="https://www.facebook.com/RunestoneInteractive" data-send="false" data-layout="button_count" data-width="300" data-show-faces="false" data-font="arial"></div>
              </li>

              <li class="divider"></li>
              <li>
                <div>
                  <b>Help support us:</b>
                </div>
                <div>
                    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
                  <input type="hidden" name="cmd" value="_s-xclick">
                  <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHNwYJKoZIhvcNAQcEoIIHKDCCByQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYAcrkqh1hn3lYqIpfXxNqe1T82EhXzCJGy1yMAmklpyZshyMkfDGe1Bhx+iwyGeoYRTTyphFmP+9M3NyO0+Q5XdHxgZPx/zYjjBxlZHgEV6jhE8bN2fHkkPf0VHfz0a0QQylQOPlKiOTZV7B37Jpk6yM47oVZ1tG/KNm0NkfmB76DELMAkGBSsOAwIaBQAwgbQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIi0GmFfOlcjuAgZBbYOo9UO+CpMQa+PYqwsUmUnJvXIImeMeNI3KVTUx5Cfk9gNMo3WzPeiB5IqZo9nRAQ0mf1qL2ecLeB5tidM+lgBUhOxfj3/FecpnVFa0263gp4g+PLw8jzhvVRdUon1K3SeO1Rzh23fIRKwnrD6btt73uwtj0sl3tGd8qz+6GIcwPDdRk9VcUffiBJT/ZagKgggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMzExMDMxMzQxMzFaMCMGCSqGSIb3DQEJBDEWBBRDJF8w+zsMr7FSk+pwinB5f5D4rzANBgkqhkiG9w0BAQEFAASBgHw1LMHpkpaqHIvDGdFE0eG+2mZlmMnUeDCBhQlbc7QMzFQYKTV94NfaebBO4PmNdADe1rq4WidSRZZbE7CzkX9IGENYnBTWY0hb2l0lGdGrJdGeWyV3ekg9WVaFMMumrekds96h3Cx7dGz2kWDzIai2iEXE/qoE+xpkyXAYZNV3-----END PKCS7-----
                  ">
                  <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
                  <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
                  </form>

                </div>
              </li>
          </ul>
        </li>
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>

        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='#'>Table of Contents</a></li>
            
            <li><a href='/runestone/static/maze/genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>

        <!-- help menu dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-question-sign" style="opacity:0.9;"></i>
          </a>
          <ul class="dropdown-menu user-menu">
            <li><a href='/runestone/static/maze/navhelp.html'>Navigation Help</a></li>
            <li><a href='/runestone/static/overview/instructor.html'>Help for Instructors</a></li>
            <li class="divider"></li>
            <li><a href='http://runestoneinteractive.org'>About Runestone</a></li>
            <li><a href='/runestone/static/help/bugreports.html'>Report A Problem</a></li>
          </ul>
        </li>
        <!-- end help menu dropdown -->

        <li class="divider-vertical"></li>

      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        <!--
          <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">The CSI 106 Maze Project</a><ul>
<li><a class="reference internal" href="#section-1-introduction">SECTION 1: Introduction</a></li>
</ul>
</li>
</ul>
</ul>
</li>
          <li class="divider-vertical"></li>
        
        
          

<script type="text/javascript">
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  $('#relations-prev').tooltip(opts);
  $('#relations-next').tooltip(opts);
</script>
        -->
        
          <li></li>
        
      </ul>

    </div>
  </div>
</div>


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content">
  
  <div class="section" id="the-csi-106-maze-project">
<h1>The CSI 106 Maze Project<a class="headerlink" href="#the-csi-106-maze-project" title="Permalink to this headline">¶</a></h1>
<div class="section" id="section-1-introduction">
<h2>SECTION 1: Introduction<a class="headerlink" href="#section-1-introduction" title="Permalink to this headline">¶</a></h2>
<p>We will be first creating a maze using test driven development techniques.  Each step of the way will begin with a test.
As you follow along with this example, you can execute the code by clicking on the run buttons. You can also change the code and rerun any of them if you want to experiment or find out more.</p>
<p>The first thing we need to test for is a Maze class.  Of course there is no Maze class.  We haven&#8217;t written it yet.  We test for it first.</p>

<textarea data-component="activecode" id=m_test_1 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
m=Maze() # see if a Maze class exists.
</textarea>
<p>This code should run without an error if there is a Maze class.</p>
<p>You should see an error when you run the code.
It&#8217;s a pretty ugly NameError:</p>
<p>You are in what we call condition RED.  The next step is to get into condition GREEN.  We do this by writing the minimal amount of code we need to make the test pass.</p>
<p>Let&#8217;s make it a little prettier first and use the try statement as follows:</p>

<textarea data-component="activecode" id=m_try_1 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
try:
   m=Maze()
except:
   print "Maze class does not yet exist. CONDITION RED"
</textarea>
<p>Much better.</p>
<p>Now let&#8217;s make this class exist.</p>

<textarea data-component="activecode" id=m_class_1 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
class Maze(object):
   """ Creates a maze. (We don't know anything more than that yet.) """
   def __init__(self):
      pass

condition="GREEN"
try:
   m=Maze()
except:
   condition="RED"
print "Condition: " + condition
</textarea>
<p>We will use the turtle module to make our maze. You may need to read up a little on the turtle
module to learn the features available to you.</p>
<p>The screen is created with the following command</p>

<textarea data-component="activecode" id=m_w_1 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
wn = turtle.Screen()
wn.bgcolor("blue")
</textarea>
<p>When you run this code you will see the blue screen we created. A blue color means a wall.
This is the visual representation of our maze. We don&#8217;t have any paths created yet. It&#8217;s all
wall.</p>
<p>Now let&#8217;s put this into the maze class. First write the test for the screen.</p>

<textarea data-component="activecode" id=m_test_screen data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
class Maze(object):
   """ Solves a maze """
   def __init__(self):
      pass

m=Maze()
assert type(m.screen)==turtle.Screen
</textarea>
<p>Now add the screen.</p>

<textarea data-component="activecode" id=m_add_screen data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
#
import turtle
class Maze(object):
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()

m=Maze()
assert type(m.screen)==turtle.Screen
</textarea>
<p>Condition is now GREEN. We also need a turtle.  Add a test for the turtle.</p>

<textarea data-component="activecode" id=m_turtle_test data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
class Maze(object):
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()

m=Maze()
assert type(m.turtle)==turtle.Turtle
</textarea>
<p>And you know the next step to get GREEN.</p>

<textarea data-component="activecode" id=m_add_turtle data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
class Maze(object):
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()

m=Maze()
assert type(m.turtle)==turtle.Turtle
</textarea>
<p>We will first be constructing our maze using the colors blue for a wall, white for a path, and yellow for the final goal.  Since we are making a path, it seems like a good starting point would be to have nothing but walls.  This means a blue screen.  We can test by looking at the bgcolor method for Screen.</p>

<textarea data-component="activecode" id=m_blue_bg data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
class Maze(object):
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')

m=Maze()
assert m.screen.bgcolor()=='blue'
assert m.screen.window_width()==400
assert m.screen.window_height()==400
</textarea>
<p>We also check the height and width of our screeen to be safe.
You should now see the blue screen. (Note that I skipped the RED to GREEN and added both the test and the code)</p>
<p>So far we have discussed the RED and GREEN condition. It&#8217;s now time to think about YELLOW.  This is the refactoring stage. Refactoring is when you modify your code to improve it without changing its function or behavior.  Unlike this example, the tests we write persist through each iteration of your development cycle (RED-GREEN-YELLOW) To save space I leave out the prior tests.  Normally you want all your tests to run all the time.</p>
<p>Anticipating change in your program is a good thing.  If you can see ways to generalize parameters, it usually helps to make your code more flexible for future changes.  For instance, notice how we are using the number 400.  Hard-coded numbers like that are a warning sign.  Usually you are helped by making that value a parameter such as &#8220;SIZE&#8221; for instance.</p>

<textarea data-component="activecode" id=m_refactor_1 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
SIZE=400
class Maze(object):
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')

m=Maze()
assert m.screen.bgcolor()=='blue'
assert m.screen.window_width()==SIZE
assert m.screen.window_height()==SIZE
</textarea>
<p>This is a very small refactoring example. We will see others as we continue.</p>
<p>Now we need to think about how we will represent our maze inside the program. The screen is the interface to people but internally we need to make decisions based on the current state of the maze.</p>
<p>I choose a matrix as the data type best suited. Each item in the matrix corresponds to a location in the maze. The size of the screen by default is 400x400.  We will keep the default for now.  The way we will draw on the screen is by using the stamp method in the turtle module and a square for the shape. (look into the documentation on the turtle module for more clarification on those methods.)</p>
<p>The default size for the square is 20x20. So we can have 20 rows and 20 columns in our matrix since the size of the screen is 400x400.  The origin is in the middle. so -190,190 corresponds to the [0][0] location of the matrix. Let&#8217;s clarify our thinking a little by writing code to draw a white square in the upper left hand corner.</p>

<textarea data-component="activecode" id=m_draw_square data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
s=turtle.Screen()
s.bgcolor('blue')
t=turtle.Turtle()
t.penup()
t.goto(-190,190)
t.shape('square')
t.color('white')
t.stamp()
</textarea>
<p>Here&#8217;s how we would draw a path along the top of the screen. Feel free to make changes to this code and experiment so you feel like you understand how the turtle works.</p>

<textarea data-component="activecode" id=m_draw_path_1 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
s=turtle.Screen()
s.bgcolor('blue')
t=turtle.Turtle()
t.penup()
for x in range(-190,210,20):
    t.goto(x,190)
    t.shape('square')
    t.color('white')
    t.stamp()
</textarea>
<p>This is all useful for learning about the tools we have.  Let&#8217;s create a test for our matrix, the internal representation of the maze.</p>

<textarea data-component="activecode" id=m_test_matrix data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
SIZE=400
class Maze(object):
      """ Solves a maze """
      def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')

m=Maze()
assert len(m.matrix)==SIZE/20
</textarea>
<p>Notice how we now use the parameter SIZE in our code.</p>
<p>This only checks for the height of our matrix but it&#8217;s good enough for now. You should weigh how much time you want to spend writing a test vs how risky is the failure.  To make this test pass we want to add a matrix to our maze. Here&#8217;s the code that does that. Notice that all the values in the matrix are 1 which corresponds to everything being a wall. That&#8217;s an arbitrary decision I just made. Seems like 0 for no wall and 1 for a wall makes sense.</p>

<textarea data-component="activecode" id=m_add_matrix data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
SIZE=400
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view. """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(SIZE/20)] for i in range(SIZE/20)]

m=Maze()
assert len(m.matrix)==SIZE/20
assert m.screen.window_width()==SIZE,"window width not correct."
assert m.screen.window_height()==SIZE,"window height not correct."
</textarea>
<p>We will start our path from the upper left hand corner, (another arbitrary choice). Let&#8217;s imagine we are digging our path through the walls. When we dig into the space, we turn a 1 in our matrix to a 0.  This indicates we have an empty space at that location.  It&#8217;s easy to then consider a function called <em>dig</em> where we pass in a direction and the turtle will dig in that direction one space if possible.</p>
<p>Since we are starting from the upper left hand corner, matrix[0][0] should be 0 and the turtle location should be -190,190.  Let&#8217;s put a reset function in so we can always get to this starting configuration.</p>

<textarea data-component="activecode" id=m_reset_test data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
#
import turtle
SIZE=400
class Maze(object):
   """ Creates a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view. """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(SIZE/20)] for i in range(SIZE/20)]


m=Maze()
m.reset()
assert m.matrix[0][0]==0
assert m.turtle.pos()==(-(SIZE/2-10),SIZE/2-10)
</textarea>
<p>Make it pass now.</p>

<textarea data-component="activecode" id=m_reset_pass data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
SIZE=400
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view. """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(SIZE/20)] for i in range(SIZE/20)]
      self.turtle.penup()

   def reset(self):
      self.turtle.goto(-(SIZE/2-10),SIZE/2-10)
      self.matrix=[[1 for i in range(SIZE/20)] for i in range(SIZE/20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0

m=Maze()
m.reset()
assert m.matrix[0][0]==0
assert m.turtle.pos()==(-(SIZE/2-10),SIZE/2-10)
</textarea>
<p>Time to refactor. How can we improve on this code?  We have some duplicate code in there.  Let&#8217;s get rid of it.</p>

<textarea data-component="activecode" id=m_dup_fix data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
SIZE=400
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view. """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.reset()

   def reset(self):
      self.turtle.penup()
      self.turtle.goto(-(SIZE/2-10),(SIZE/2-10))
      self.matrix=[[1 for i in range(SIZE/20)] for i in range(SIZE/20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0

m=Maze()
m.reset()
assert m.matrix[0][0]==0
assert m.turtle.pos()==(-(SIZE/2-10),SIZE/2-10)
</textarea>
<p>I think of the turtle as sort-of digging it&#8217;s way through the walls to make the maze.</p>
<p>We are at a point where we can consider the <em>dig</em> function.  I imagine m.dig(EAST) will move the turtle one square to the East on the screen. But what is EAST and why and I using capitals?  In programming it is common to map words to constants and when we do that we often use all capitals to indicate that&#8217;s what is going on. The way we do this in python is simple.</p>

<textarea data-component="activecode" id=m_const data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
EAST=0
NORTH=1
WEST=2
SOUTH=3
</textarea>
<p>If we do this, it makes it easier since we don&#8217;t have to remember 0 is East. So we know we want one argument for <em>dig</em>.  What do we want back?  If we get back the position of the turtle, we can tell if it succeeded in moving and we can tell where it is also. After a reset we should be able to dig East. So calling m.dig(EAST) should return (-170,190).  Now we know how to write our test.</p>

<textarea data-component="activecode" id=m_test_dig data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,direction):
      pass

m=Maze()
m.reset()
r=m.dig(EAST)
assert r==(-170,190), "got " + str(r)
</textarea>
<p>To create a passing test, we need to add the code for <em>dig</em>. One thing that becomes very obvious is that we need to map the position of the turtle into the matrix locations because we can&#8217;t use the turtle position to index the matrix directly. What would be convenient is to be able to access the matrix with the turtle position.  Something like</p>

<textarea data-component="activecode" id=m_access_matrix data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,direction):
      pass

m=Maze()
m.reset()
value=m.getMatrixValueAt(m.turtle.position)
m.setMatrixValueAt(m.turtle.position,value)
</textarea>
<p>At reset conditions, the matrix value would be 0 at [0][0] because we have a space there.  Our test should be</p>

<textarea data-component="activecode" id=m_test_map data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
m.reset()
assert m.getMatrixValueAt(m.turtle.position)==0
</textarea>
<p>Make it pass.</p>

<textarea data-component="activecode" id=m_test_dig data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self):
      pass
   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v

m=Maze()
m.reset()
assert m.getMatrixValueAt(m.turtle.position())==0
# we are putting this test on hold for now
# assert m.dig(EAST)==(-170,190)
</textarea>
<p>Now for setMatrixValueAt(pos).</p>

<textarea data-component="activecode" id=m_test_dig2 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self):
      pass
   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      return True

m=Maze()
m.reset()
m.reset()
assert m.getMatrixValueAt(m.turtle.position())==0
assert m.setMatrixValueAt(m.turtle.position(),1)==True
assert m.matrix[0][0]==1
# we are putting this test on hold for now
# assert m.dig(EAST)==(-170,190)
</textarea>
<p>Nice! Now we can just use our turtle position to set the matrix. But after we set the matrix to 1, we should see the white square dissappear if it properly represents our matrix. Let&#8217;s fix that.</p>

<textarea data-component="activecode" id=m_test_dig3 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self):
      pass
   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()
m.reset()
assert m.getMatrixValueAt(m.turtle.position())==0
assert m.setMatrixValueAt(m.turtle.position(),1)==True
assert m.matrix[0][0]==1
# we are putting this test on hold for now
# assert m.dig(EAST)==(-170,190)
</textarea>
<p>Now we can map turtle position to matrix element. Remember we are trying to implement <em>dig</em> ultimately. Let&#8217;s  manually do a little digging.</p>

<textarea data-component="activecode" id=m_test_dig4 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self):
      pass
   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()

m.turtle.goto(-170,190)
m.turtle.stamp()
m.setMatrixValueAt(m.turtle.position(),0)
</textarea>
<p>So now with this code we see that digging east moves the turtle to -170,190 and sets the value of the matrix at that point to 0.</p>
<p>Let&#8217;s add our test and code to make it pass.</p>

<textarea data-component="activecode" id=m_test_dig5 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
       self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()

   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()
m.dig(EAST)
assert m.getMatrixValueAt(m.turtle.position())==0
assert m.turtle.position() == (-170,190)
</textarea>
<p>Now let&#8217;s do a reset and dig south.  I&#8217;m showing both the test and the code to make it pass here.</p>

<textarea data-component="activecode" id=m_test_dig6 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
       self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
       self.setMatrixValueAt(self.turtle.position(),0)

     return self.turtle.position()


   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()
m.dig(SOUTH)
assert m.getMatrixValueAt(m.turtle.position())==0
assert m.turtle.position() == (-190,170)
</textarea>
<p>We can&#8217;t dig west from the reset condition so let&#8217;s make sure that is understood by the function.  We need to assert that digging west just returns the original location of the turtle so we know it didn&#8217;t move. Note that the previous code is included in the following.</p>

<textarea data-component="activecode" id=m_test_dig7 data-lang="python"   data-include=m_test_dig6 data-timelimit=25000  data-codelens="true" data-audio=''     >
m=Maze()
m.reset()
assert m.dig(WEST) == (-190,190)
</textarea>
<p>Well this test actually passed without us doing anything but it&#8217;s just a fluke because we ignore WEST and in this case that&#8217;s what we want to do.  Let&#8217;s get a little more involved with our testing.  We can go East and South, so let&#8217;s try going East, South, and then West.  We should see our failure then.</p>

<textarea data-component="activecode" id=m_test_dig9 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
       self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
       self.setMatrixValueAt(self.turtle.position(),0)

     return self.turtle.position()


   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()
m.dig(EAST)
m.dig(SOUTH)
r=m.dig(WEST)
assert r == (-190,170), "should be at (-190,170) but got " + str(r)
</textarea>
<p>Of course we can see how ignoring WEST was just a fluke here. Sometimes writing tests is a little more involved than at first perceived.  Now let&#8217;s get this test to pass.</p>

<textarea data-component="activecode" id=m_test_dig10 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()


   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()
m.dig(EAST)
m.dig(SOUTH)
r=m.dig(WEST)
assert r == (-190,170), "should be at (-190,170) but got " + str(r)
</textarea>
<p>We have dug ourselves a nice square. One last direction to test, NORTH.  Here&#8217;s both the test and the solution.</p>

<textarea data-component="activecode" id=m_test_dig11 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   """ Solves a maze """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  NORTH:
       if self.turtle.position()[1]<190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
         self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()


   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True

m=Maze()
m.reset()
m.dig(EAST)
m.dig(SOUTH)
m.dig(WEST)
r=m.dig(NORTH)
assert r == (-190,190), "should be at (-190,190) but got " + str(r)
</textarea>
<p>Here is our Maze class.</p>

<textarea data-component="activecode" id=m_maze_class data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  NORTH:
       if self.turtle.position()[1]<190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
         self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()


   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      v=self.matrix[x][y]
      return v
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      return True
</textarea>
<p>Our code examples will now just include that invisibly and we will override functions.</p>
<p>We now have our dig method.  We can dig in all 4 directions.  There are more tests we can add for more complete confidence in the method but for now, let&#8217;s move on.   We may go back and add some more tests for <em>dig</em> if we find things are breaking.</p>
<p>One thing we need to be careful about when digging our paths in the maze is that we need to make sure we don&#8217;t go into another preexisting path.  Our tests make a big square in the upper left hand corner but we really don&#8217;t want that to happen.  We want some wall between paths.  Lets prevent digging if it means we connect to a preexisting path.  This means that the 3 locations surrounding the new space must be walls.  Spaces outside the boundary of the screen are considered walls.</p>
<p>How do we test this? If we make a space at location m.matrix[0][2] then we should not be able to dig EAST from m.matrix[0][0].</p>

<textarea data-component="activecode" id=m_dig_noconnect_test data-lang="python"   data-include=m_maze_class data-timelimit=25000  data-codelens="true" data-audio=''     >
class Maze2(Maze):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         if self.getMatrixValueAt((self.turtle.position()[0]+40,self.turtle.position()[1]))>0:
           self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  NORTH:
       if self.turtle.position()[1]<190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
         self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()


m=Maze2()
m.reset()
m.setMatrixValueAt((-150,190),0)
r=m.dig(EAST)
assert r==(-190,190),"Not at Home position, got " + str(r)
</textarea>
<p>This passes but why don&#8217;t we see the white square appearing at location (-150,190)?  We assumed the turtle was where it should be to stamp the value but we need to move the turtle to that location first and then move the turtle back. So we correct the setMatrixValueAt method.</p>

<textarea data-component="activecode" id=m_dig_noconnect_test2 data-lang="python"   data-include=m_maze_class data-timelimit=25000  data-codelens="true" data-audio=''     >
class Maze2(Maze):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         if self.getMatrixValueAt((self.turtle.position()[0]+40,self.turtle.position()[1]))>0:
           self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
         self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  NORTH:
       if self.turtle.position()[1]<190:
         self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
         self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()
   def setMatrixValueAt(self,pos,value):
      y=int((pos[0]+200)/20)
      x=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[y][x]=value
      except:
         return False
      oldPos=self.turtle.position()
      self.turtle.goto(pos)
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      self.turtle.goto(oldPos)
      return True


m=Maze2()
m.reset()
m.setMatrixValueAt((-150,190),0)
r=m.dig(EAST)
assert r==(-190,190),"Not at Home position, got " + str(r)
</textarea>
<p>Now we see the white square at (-150,190).  I will leave it to you to handle the other directions. After you are done, you should have a class that looks like this.</p>

<textarea data-component="activecode" id=m_maze_class_2 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         if self.turtle.position()[0]+40 > 190:
            return self.turtle.position
         if self.getMatrixValueAt((self.turtle.position()[0]+40,self.turtle.position()[1]))>0:
           self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         if self.turtle.position()[1]-40 < -190:
           return self.turtle.position()
         if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]-40))>0:
           self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         if self.turtle.position()[0]-40 < -190:
           return self.turtle.position()
         if self.getMatrixValueAt((self.turtle.position()[0]-40,self.turtle.position()[1]))>0:
           self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  NORTH:
       if self.turtle.position()[1]<190:
         if self.turtle.position()[1]+40 > 190:
           return self.turtle.position()
         if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]+40))>0:
           self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
           self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()
   def setMatrixValueAt(self,pos,value):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[x][y]=value
      except:
         return False
      oldPos=self.turtle.position()
      self.turtle.goto(pos)
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      self.turtle.goto(oldPos)
      return True
   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      if (pos[0]+200)/20<0 or x>19:
          return -1
      if y<0 or y>19:
          return -1
      v=self.matrix[x][y]
      return v
</textarea>
<p>And the tests.</p>

<textarea data-component="activecode" id=m_test_dig2path data-lang="python"   data-include=m_maze_class_2 data-timelimit=25000  data-codelens="true" data-audio=''     >
m=Maze()
m.reset()
m.setMatrixValueAt((-190,150),0)
print m.turtle.position()
r=m.dig(SOUTH)
assert r==(-190,190),"got " + str(r)
m.setMatrixValueAt((-150,190),0)
r=m.dig(EAST)
assert r==(-190,190),"got " + str(r)
m.turtle.goto(-150,150)
r=m.dig(WEST)
assert r==(-150,150),"got " + str(r)
m.turtle.goto(-190,150)
r=m.dig(NORTH)
assert r==(-190,150),"got " + str(r)
m.reset()
r=m.dig(NORTH)
assert r==(-190,190),"got " + str(r)
m.turtle.goto(-190,-170)
print m.turtle.position()[1]-20
r=m.dig(SOUTH)
assert r==(-190,-170),"got " + str(r)
</textarea>
<p>Again, there could be more testing. It&#8217;s a judgement call as to how much you want to test. How much energy you have and how important something is, etc.</p>
<p>Now it&#8217;s a good idea to not reinvent the wheel! Look up algorithms for maze generation and you will find a number of web sites.  We will use the depth-first search algorithm</p>
<p>(<a class="reference external" href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">https://en.wikipedia.org/wiki/Maze_generation_algorithm</a>)</p>
<ol class="arabic">
<li><p class="first">Start at the upper left hand corner</p>
</li>
<li><dl class="first docutils">
<dt>Mark that cell as visited and get a list of its neighbors.  For each neighbor, starting with a randomly selected neighbor</dt>
<dd><ul class="first last simple">
<li>if that neighbor hasn&#8217;t been visited, remove the wall between this cell and that neighborand then recur with that neighbor as the current cell.</li>
</ul>
</dd>
</dl>
</li>
</ol>
<p>It might be nice to have a method called <em>neighbors</em> which returns the state of the cells neighboring the current cell.</p>
<p><em>neighbors</em> should return 4 values, the neighbors in all 4 directions.  At the boundaries, the values outside the matrix should be -1 to indicate invalid locations.</p>
<p>A neighbor is actually 2 cells away since walls take up a cell&#8217;s width.</p>
<p>At reset condition then, <em>neighbors</em> should return [-1,1,1,-1] for the NORTH, SOUTH, EAST, and WEST neighbors.</p>

<textarea data-component="activecode" id=m_test_digPath_1 data-lang="python"   data-include=m_maze_class_2 data-timelimit=25000  data-codelens="true" data-audio=''     >
m=Maze()
m.reset()
assert m.neighbors()==[-1,1,1,-1]
</textarea>
<p>Now to implement.</p>

<textarea data-component="activecode" id=m_test_digPath_2 data-lang="python"   data-include=m_maze_class_2 data-timelimit=25000  data-codelens="true" data-audio=''     >
class NewMaze(Maze):
   def neighbors(self):
     p=self.turtle.position()
     r=[]
     r.append([(p[0],p[1]+40),m.getMatrixValueAt((p[0],p[1]+40))])
     r.append([(p[0],p[1]-40),m.getMatrixValueAt((p[0],p[1]-40))])
     r.append([(p[0]+40,p[1]),m.getMatrixValueAt((p[0]+40,p[1]))])
     r.append([(p[0]-40,p[1]),m.getMatrixValueAt((p[0]-40,p[1]))])
     return r

m=NewMaze()
m.reset()
r = m.neighbors()
assert (r[0][1]==-1 and r[1][1]==1 and r[2][1]==1 and r[3][1]==-1),"got " + str(r)
m.turtle.goto(-170,170)
r = m.neighbors()
assert (r[0][1]==-1 and r[1][1]==1 and r[2][1]==1 and r[3][1]==-1),"got " + str(r)
m.turtle.goto(-150,150)
r = m.neighbors()
assert (r[0][1]==1 and r[1][1]==1 and r[2][1]==1 and r[3][1]==1), "got " + str(r)
</textarea>
<p>Now that we have added neighbors, let&#8217;s put it into our Maze class rather than just overloading it.</p>

<textarea data-component="activecode" id=m_maze_class_3 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
import turtle
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
   """ Solves a maze using a 20x20 matrix as an internal model
          and a 400x400 screen graphical view.
       reset() puts the turtle in the upper left hand corner.
       getMatrixValueAt(position) returns the matrix value at the tuple position
   """
   def __init__(self):
      self.screen=turtle.Screen()
      self.turtle=turtle.Turtle()
      self.screen.bgcolor('blue')
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.turtle.penup()
   def reset(self):
      self.turtle.goto(-190,190)
      self.matrix=[[1 for i in range(20)] for i in range(20)]
      self.screen.bgcolor('blue')
      self.turtle.shape('square')
      self.turtle.color('white')
      self.turtle.stamp()
      self.matrix[0][0]=0
   def neighbors(self):
     p=self.turtle.position()
     r=[]
     r.append([(p[0],p[1]+40),m.getMatrixValueAt((p[0],p[1]+40))])
     r.append([(p[0],p[1]-40),m.getMatrixValueAt((p[0],p[1]-40))])
     r.append([(p[0]+40,p[1]),m.getMatrixValueAt((p[0]+40,p[1]))])
     r.append([(p[0]-40,p[1]),m.getMatrixValueAt((p[0]-40,p[1]))])
     return r
   def dig(self,dir):
     if dir == EAST:
       if self.turtle.position()[0]<190:
         if self.turtle.position()[0]+40 > 190:
            return self.turtle.position
         if self.getMatrixValueAt((self.turtle.position()[0]+40,self.turtle.position()[1]))>0:
           self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir == SOUTH:
       if self.turtle.position()[1]>-190:
         if self.turtle.position()[1]-40 < -190:
           return self.turtle.position()
         if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]-40))>0:
           self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  WEST:
       if self.turtle.position()[0]>-190:
         if self.turtle.position()[0]-40 < -190:
           return self.turtle.position()
         if self.getMatrixValueAt((self.turtle.position()[0]-40,self.turtle.position()[1]))>0:
           self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
           self.setMatrixValueAt(self.turtle.position(),0)
     elif dir ==  NORTH:
       if self.turtle.position()[1]<190:
         if self.turtle.position()[1]+40 > 190:
           return self.turtle.position()
         if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]+40))>0:
           self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
           self.setMatrixValueAt(self.turtle.position(),0)
     return self.turtle.position()
   def setMatrixValueAt(self,pos,value):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      try:
         self.matrix[x][y]=value
      except:
         return False
      oldPos=self.turtle.position()
      self.turtle.goto(pos)
      if value==0:
         self.turtle.color('white')
         self.turtle.stamp()
      if value==1:
         self.turtle.color('blue')
         self.turtle.stamp()
      self.turtle.goto(oldPos)
      return True
   def getMatrixValueAt(self,pos):
      x=int((pos[0]+200)/20)
      y=20-int((pos[1]+200)/20)-1
      if (pos[0]+200)/20<0 or x>19:
          return -1
      if ((pos[1]+200)/20)>19.5 or ((pos[1]+200)/20)<0:
          return -1
      v=self.matrix[x][y]
      return v
</textarea>
<p>Now with these constants added we can make the code a little more readable.</p>

<textarea data-component="activecode" id=cnst2 data-lang="python"   data-include=m_maze_class_3 data-timelimit=25000  data-codelens="true" data-audio=''     >
INVALID = -1
EMPTY = 0
WALL = 1
VISITED = 2
END = 3

m=Maze()
m.reset()
r = m.neighbors()
assert (r[0][1]==INVALID and r[1][1]==WALL and r[2][1]==WALL and r[3][1]==INVALID),"got " + str(r)
m.turtle.goto(-170,170)
r = m.neighbors()
assert (r[0][1]==INVALID and r[1][1]==WALL and r[2][1]==WALL and r[3][1]==INVALID),"got " + str(r)
m.turtle.goto(-150,150)
r = m.neighbors()
assert (r[0][1]==WALL and r[1][1]==WALL and r[2][1]==WALL and r[3][1]==WALL), "got " + str(r)
</textarea>
<p>We are now ready to start implementing the algorithm.  We will call the method create().  It will be recursively calling itself but to start we will just have it run one iteration.  That way we can test it.</p>
<p>Our Maze class as it stands now.</p>

<textarea data-component="activecode" id=m_maze_class_4 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
INVALID = -1
EMPTY = 0
WALL = 1
VISITED = 2
END = 3


import turtle
import random
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
    """ Solves a maze using a 20x20 matrix as an internal model
             and a 400x400 screen graphical view.
          reset() puts the turtle in the upper left hand corner.
          getMatrixValueAt(position) returns the matrix value at the tuple position
    """

    def __init__(self):
        self.screen=turtle.Screen()
        self.turtle=turtle.Turtle()
        self.screen.bgcolor('blue')
        self.matrix=[[1 for i in range(20)] for i in range(20)]
        self.turtle.penup()

    def reset(self):
        self.turtle.goto(-190,190)
        self.matrix=[[1 for i in range(20)] for i in range(20)]
        self.screen.bgcolor('blue')
        self.turtle.shape('square')
        self.turtle.color('white')
        self.turtle.stamp()
        self.matrix[0][0]=0

    def neighbors(self):
        p=self.turtle.position()
        r=[]
        r.append([(p[0],p[1]+40),m.getMatrixValueAt((p[0],p[1]+40))])
        r.append([(p[0],p[1]-40),m.getMatrixValueAt((p[0],p[1]-40))])
        r.append([(p[0]+40,p[1]),m.getMatrixValueAt((p[0]+40,p[1]))])
        r.append([(p[0]-40,p[1]),m.getMatrixValueAt((p[0]-40,p[1]))])
        return r

    def dig(self,dir):
        if dir == EAST:
            if self.turtle.position()[0]<190:
                if self.turtle.position()[0]+20 > 190:
                    return self.turtle.position
            if self.getMatrixValueAt((self.turtle.position()[0]+20,self.turtle.position()[1]))>0:
                self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
                self.setMatrixValueAt(self.turtle.position(),0)
        elif dir == SOUTH:
            if self.turtle.position()[1]>-190:
                if self.turtle.position()[1]-20 < -190:
                    return self.turtle.position()
            if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]-20))>0:
                self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
                self.setMatrixValueAt(self.turtle.position(),0)
        elif dir ==  WEST:
            if self.turtle.position()[0]>-190:
                if self.turtle.position()[0]-20 < -190:
                    return self.turtle.position()
            if self.getMatrixValueAt((self.turtle.position()[0]-20,self.turtle.position()[1]))>0:
                self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
                self.setMatrixValueAt(self.turtle.position(),0)
        elif dir ==  NORTH:
            if self.turtle.position()[1]<190:
                if self.turtle.position()[1]+20 > 190:
                    return self.turtle.position()
            if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]+20))>0:
                self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
                self.setMatrixValueAt(self.turtle.position(),0)
        return self.turtle.position()

    def setMatrixValueAt(self,pos,value):
        x=int((pos[0]+200)/20)
        y=20-int((pos[1]+200)/20)-1
        try:
            self.matrix[x][y]=value
        except:
            return False
        oldPos=self.turtle.position()
        self.turtle.goto(pos)
        if value==0:
            self.turtle.color('white')
            self.turtle.stamp()
        if value==1:
            self.turtle.color('blue')
            self.turtle.stamp()
        self.turtle.goto(oldPos)
        return True

    def getMatrixValueAt(self,pos):
        x=int((pos[0]+200)/20)
        y=20-int((pos[1]+200)/20)-1
        if (pos[0]+200)/20<0 or x>19:
            return -1
        if ((pos[1]+200)/20)>19.5 or ((pos[1]+200)/20)<0:
            return -1
        v=self.matrix[x][y]
        return v
</textarea>
<p>Let&#8217;s just say for test number one, we will have the first part dug. So either it will be a path to the right or a path down.  Our test should check both directions and see if one has been successfully dug.</p>

<textarea data-component="activecode" id=m_test_create_1 data-lang="python"   data-include=m_maze_class_4 data-timelimit=25000  data-codelens="true" data-audio=''     >
def direction(pos1,pos2):
    """ returns the direction from position 1 to position 2 """
    if pos1[0]==pos2[0]: # x position the same, either NORTH or SOUTH
        if pos1[1]>pos2[1]: # NORTH
            return NORTH
        else:
            return SOUTH
    else:
        if pos2[0]>pos1[0]: # EAST
            return EAST
        else:
            return WEST


class Maze2(Maze):
    def makeMaze(self):
        n=self.neighbors()
        while len(n)>0:
            nchoice=random.choice(n)
            n.remove(nchoice)
            if nchoice[1]==WALL:
                d=direction(self.turtle.position(),nchoice[0])
                self.dig(d)
                self.dig(d)
                return

m=Maze2()
m.reset()
m.makeMaze()
assert ((m.getMatrixValueAt((-170,190))==EMPTY and m.getMatrixValueAt((-150,190))==EMPTY) or  \
       (m.getMatrixValueAt((-190,170))==EMPTY and m.getMatrixValueAt((-190,150))==EMPTY)),"got " + \
       str(m.getMatrixValueAt((-170,190))) + "," + \
       str(m.getMatrixValueAt((-150,190))) + "," + \
       str(m.getMatrixValueAt((-190,170))) + "," + \
       str(m.getMatrixValueAt((-190,150)))
</textarea>
<p>Now the algorithm says we should recur what we just did. So let&#8217;s try.</p>

<textarea data-component="activecode" id=m_test_create_2 data-lang="python"   data-include=m_maze_class_4 data-timelimit=25000  data-codelens="true" data-audio=''     >
def direction(pos1,pos2):
    """ returns the direction from position 1 to position 2 """
    if pos1[0]==pos2[0]: # x position the same, either NORTH or SOUTH
        if pos1[1]<pos2[1]: # NORTH
            return NORTH
        else:
            return SOUTH
    else:
        if pos2[0]>pos1[0]: # EAST
            return EAST
        else:
            return WEST


class Maze2(Maze):
    def makeMaze(self):
        n=self.neighbors() # get the 4 neighbors.
        # save the position of the turtle
        # we need to start there for each neighbors
        oldpos=self.turtle.position()
        while len(n)>0:
            nchoice=random.choice(n)
            n.remove(nchoice) # remove so eventually the length will be 0
            self.turtle.goto(oldpos)
            # we must use getMatrixValueAt rather than the value in nchoice
            # because it may have changed from a prior recursive call.
            if self.getMatrixValueAt(nchoice[0])==WALL:
                d=direction(self.turtle.position(),nchoice[0])
                self.dig(d) # this removes the wall
                self.dig(d) # this is the next occupied cell.
                self.makeMaze() # recursively do it again from the new cell


import sys
sys.setExecutionLimit(50000)
m=Maze2()
m.reset()
m.makeMaze()
assert ((m.getMatrixValueAt((-170,190))==EMPTY and m.getMatrixValueAt((-150,190))==EMPTY) or  \
       (m.getMatrixValueAt((-190,170))==EMPTY and m.getMatrixValueAt((-190,150))==EMPTY)),"got " + \
       str(m.getMatrixValueAt((-170,190))) + "," + \
       str(m.getMatrixValueAt((-150,190))) + "," + \
       str(m.getMatrixValueAt((-190,170))) + "," + \
       str(m.getMatrixValueAt((-190,150)))
</textarea>
<p>Hooray!</p>
<p>Now let&#8217;s put it all together in our Maze model</p>

<textarea data-component="activecode" id=m_maze_class_5 data-lang="python"    data-timelimit=25000  data-codelens="true" data-audio=''     >
def direction(pos1,pos2):
    """ returns the direction from position 1 to position 2 """
    if pos1[0]==pos2[0]: # x position the same, either NORTH or SOUTH
        if pos1[1]<pos2[1]: # NORTH
            return NORTH
        else:
            return SOUTH
    else:
        if pos2[0]>pos1[0]: # EAST
            return EAST
        else:
            return WEST


import turtle
import random
INVALID = -1; EMPTY = 0; WALL = 1; VISITED = 2; END = 3
EAST=0;NORTH=1;WEST=2;SOUTH=3
class Maze(object):
    """ Solves a maze using a 20x20 matrix as an internal model
             and a 400x400 screen graphical view.
          reset() puts the turtle in the upper left hand corner.
          getMatrixValueAt(position) returns the matrix value at the tuple position
    """

    def __init__(self):
        self.screen=turtle.Screen()
        self.turtle=turtle.Turtle()
        self.screen.bgcolor('blue')
        self.matrix=[[1 for i in range(20)] for i in range(20)]
        self.turtle.penup()
        self.reset()

    def makeMaze(self):
        n=self.neighbors()
        oldpos=self.turtle.position()
        while len(n)>0:
            nchoice=random.choice(n)
            n.remove(nchoice)
            self.turtle.goto(oldpos)
            if self.getMatrixValueAt(nchoice[0])==WALL:
                d=direction(self.turtle.position(),nchoice[0])
                self.dig(d)
                self.dig(d)
                self.makeMaze()

    def reset(self):
        self.turtle.goto(-190,190)
        self.matrix=[[1 for i in range(20)] for i in range(20)]
        self.screen.bgcolor('blue')
        self.turtle.shape('square')
        self.turtle.color('white')
        self.turtle.stamp()
        self.matrix[0][0]=0

    def neighbors(self):
        p=self.turtle.position()
        r=[]
        r.append([(p[0],p[1]+40),m.getMatrixValueAt((p[0],p[1]+40))])
        r.append([(p[0],p[1]-40),m.getMatrixValueAt((p[0],p[1]-40))])
        r.append([(p[0]+40,p[1]),m.getMatrixValueAt((p[0]+40,p[1]))])
        r.append([(p[0]-40,p[1]),m.getMatrixValueAt((p[0]-40,p[1]))])
        return r

    def dig(self,dir):
        if dir == EAST:
            if self.turtle.position()[0]<190:
                if self.turtle.position()[0]+20 > 190:
                    return self.turtle.position
            if self.getMatrixValueAt((self.turtle.position()[0]+20,self.turtle.position()[1]))>0:
                self.turtle.goto(self.turtle.position()[0]+20,self.turtle.position()[1])
                self.setMatrixValueAt(self.turtle.position(),0)
        elif dir == SOUTH:
            if self.turtle.position()[1]>-190:
                if self.turtle.position()[1]-20 < -190:
                    return self.turtle.position()
            if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]-20))>0:
                self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]-20)
                self.setMatrixValueAt(self.turtle.position(),0)
        elif dir ==  WEST:
            if self.turtle.position()[0]>-190:
                if self.turtle.position()[0]-20 < -190:
                    return self.turtle.position()
            if self.getMatrixValueAt((self.turtle.position()[0]-20,self.turtle.position()[1]))>0:
                self.turtle.goto(self.turtle.position()[0]-20,self.turtle.position()[1])
                self.setMatrixValueAt(self.turtle.position(),0)
        elif dir ==  NORTH:
            if self.turtle.position()[1]<190:
                if self.turtle.position()[1]+20 > 190:
                    return self.turtle.position()
            if self.getMatrixValueAt((self.turtle.position()[0],self.turtle.position()[1]+20))>0:
                self.turtle.goto(self.turtle.position()[0],self.turtle.position()[1]+20)
                self.setMatrixValueAt(self.turtle.position(),0)
        return self.turtle.position()

    def setMatrixValueAt(self,pos,value):
        x=int((pos[0]+200)/20)
        y=20-int((pos[1]+200)/20)-1
        try:
            self.matrix[x][y]=value
        except:
            return False
        oldPos=self.turtle.position()
        self.turtle.goto(pos)
        if value==0:
            self.turtle.color('white')
            self.turtle.stamp()
        if value==1:
            self.turtle.color('blue')
            self.turtle.stamp()
        self.turtle.goto(oldPos)
        return True

    def getMatrixValueAt(self,pos):
        x=int((pos[0]+200)/20)
        y=20-int((pos[1]+200)/20)-1
        if (pos[0]+200)/20<0 or x>19:
            return -1
        if ((pos[1]+200)/20)>19.5 or ((pos[1]+200)/20)<0:
            return -1
        v=self.matrix[x][y]
        return v

import sys
sys.setExecutionLimit(50000)

m=Maze()
m.makeMaze()
m.turtle.goto(170,-170)
m.turtle.color("yellow")
m.turtle.stamp()
</textarea>
<p>Next part: Part 2
Part 2: SOLVING THE MAZE</p>
<p>In this part, we will be adding to the Maze class to solve the maze we just built.</p>
</div>
</div>


  
      

<script type="text/javascript">

  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
  
</script>
  
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2015 michaeltoth.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </p>
  </div>
</footer>



<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-32029811-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



  </body>
</html>